F. Circular Xor Reversal
time limit per test2 seconds
memory limit per test256 megabytes
inputstandard input
outputstandard output
You have an array
a
0
,
a
1
,…,
a
n−1
of length
n
. Initially,
a
i
=
2
i
for all
0≤i<n
. Note that array
a
is zero-indexed.
You want to reverse this array (that is, make
a
i
equal to
2
n−1−i
for all
0≤i<n
). To do this, you can perform the following operation no more than
250000
times:
Select an integer
i
(
0≤i<n
) and replace
a
i
by
a
i
⊕
a
(i+1)modn
.
Here,
⊕
denotes the bitwise XOR operation.
Your task is to find any sequence of operations that will result in the array
a
being reversed. It can be shown that under the given constraints, a solution always exists.
Input
The first line contains a single integer
n
(
2≤n≤400
) — the length of the array
a
.
Output
On the first line print one integer
k
(
0≤k≤250000
) — the number of operations performed.
On the second line print
k
integers
i
1
,
i
2
,…,
i
k
(
0≤
i
j
<n
). Here,
i
j
should be the integer selected on the
j
-th operation.
Note that you don't need to minimize the number of operations.
Examples
input
Copy
2
output
Copy
3
1 0 1
input
Copy
3
output
Copy
9
1 0 1 0 2 1 0 1 0 
Note
In the notes, the elements on which the operations are performed are colored red.
In the first test case, array
a
will change in the following way:
[1,2]→[1,3]→[2,3]→[2,1]
.
In the second test case, array
a
will change in the following way:
[1,2,4]→[1,6,4]→[7,6,4]→[7,2,4]→[5,2,4]→[5,2,1]→[5,3,1]→[6,3,1]→[6,2,1]→[4,2,1]
.